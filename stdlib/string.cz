# string.find returns the offset of the given substring
# or -1 if it isn't found.
let string.find = fn(needle) {
    # get details about ourself
    mutable i = 0;
    let l = len(self);

    # the length of our search string.
    let L = len(needle);

    # get a substring at each possible position
    for (i < l) {
        let possible = self.substr(i, L);
        # does this match?
        if (possible == needle) {
            return i;
        }

        i++;
    }

    return -1;
};

assert("\"zac\".find(\"a\") == 1");
assert("\"zac\".find(\"c\") == 2");
assert("\"zac\".find(\"anger\") == -1");
assert("\"天研\".find(\"天研\") == 0");
assert("\"st天eve研es\".find(\"研\") == 6");

# string.interpolate replaces ${blah} with the value of "blah" from
# the specified hash.
let string.interpolate = fn(hsh) {
    let reg = "(?s)^(.*?)\\$\\{([^\\}]+)\\}(.*)";
    let out = match(reg, self);

    for (out) {
        let pre = out[0];
        let tok = out[1];
        let pst = out[2];
        let self = pre + string(hsh[tok]) + pst;
        let out = match(reg, self);
    }

    return self;
};

# string.split returns an array splitting on any characters included
# in the separator string.
# By default the split is on whitespace: " ", "TAB", & "RETURN".
let string.split = fn(sep = " \r\t\n") {
    mutable i = 0;
    let l = len(self);
    mutable r = [];

    mutable tmp = "";

    for (i < l) {
        # get the character.
        let c = self[i];

        # is the character one of our split-characters?
        if (sep.find(c) != -1) {

            # push any previously-accumulated token into our array.
            if (len(tmp) > 0) {
                r = push(r, tmp);
            }
            tmp = "";

        } else {
            # store the character into our accumulator.
            tmp += c;
        }

        i++;
    }

    # Do we have a dangling-string? If so append it.
    if (len(tmp) > 0) {
        r = push(r,tmp);
    }

    return r;
};

assert("len(\"1 2 3\".split()) == 3");
assert("type(\"1 2 3\".split(\"2\")) == \"array\"");

# string.replace removes a value from a string, replacing it with a new value.
let string.replace = fn(old, new) {
    mutable s = self;
    mutable index = s.find(old);

    for (index >= 0) {
        # get the prefix
        let pre = s.substr(0, index);

        # get the suffix
        let suf = s.substr(index + len(old));

        s = pre + new + suf;

        index = s.find(old);
    }

    return s;
};

assert("zac".replace("a", "A") == "zAc", "string.replace() failed");
assert("zac".replace("A", "Q") == "zac", "string.replace() failed");

# Trim leading & trailing whitespace from the given string.
let string.trim = fn() {
    return self.ltrim().rtrim();
};

assert("  ".trim() == "", "string.trim failed");
assert(" 1 ".trim() == "1", "string.trim failed");

# Convert the given string to lower-case.
let string.tolower = fn() {
    mutable r = "";

    foreach char in self {
        if (char >= "A" && char <= "Z") {
            char = char.ord();
            char += 32;
            char = char.chr();
        }

        r += char;
    }

    return r;
};

assert("Zac".tolower() == "zac", "string.tolower() failed");
assert("天研".tolower() == "天研", "string.tolower() failed");

# Convert a string to a number (Possibly an int, possibly a float)
let string.to_number = fn() {
    let reg = "\\.";
    let out = match(reg, self);

    if (out) {
        return(self.to_f());
    } else {
        return(self.to_i());
    }
};

assert("3.13".to_number() == 3.13, "string.tonumber() failed");
assert(type("3.13".to_number()) == "float", "string.tonumber() failed");
assert("313".to_number() == 313, "string.tonumber() failed");
assert(type("313".to_number()) == "integer", "string.tonumber() failed");

# Convert the given string to upper-case.
let string.toupper = fn() {
    mutable r = "";

    foreach char in self {
        if (char >= "a" && char <= "z") {
            char = char.ord();
            char -= 32;
            char = char.chr();
        }

        r += char;
    }

    return r;
};

assert("zac".toupper() == "ZAC", "string.toupper() failed");
assert("天研".toupper() == "天研", "string.toupper() failed");
