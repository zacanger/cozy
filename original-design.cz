# moving bits of this into the examples dir and the stdlib as i go

# Variadic functions use the ... operator. Convention is to use the name
# `args`, but it's not enforced.
example = fn (...args) {
  # args is an array
  for arg in args {
    # do stuff
  }
}
# If you want to use named paramaters as well,
# varargs obviously need to come last.
exampleWithOtherArgs = fn (foo, bar, ...args) {}
# Length should work with strings, arrays, and dictionaries
# TODO: This might make more sense to implement in the host language
length = fn (iterable) {
  ret! = 0
  for i in interable {
      ret! = ret! + 1
  }
  return ret!
}
# TODO: This might make more sense to implement in the host language
# range = fn (...args) {
#   start! = args[0]
#   end! = args[1]
#   step! = if length(args) == 3 then args[2] else 1
#   # TODO: ...
# }
# TODO: Flatten impl or syntax?
range = fn (a, b) if a > b then [] else flatten([a, range(a + 1, b)])
# Errors
_error = fn (type) {
  return fn (...args) {
    message = args[0]
    stack = args[1]
    code = if length(args) == 3 then args[2] else 1
    formatted = "{type}: {message}"
    return {
      code: code,
      error: formatted,
      message: message,
      stack: stack,
      type: type,
    }
  }
}
typeError = _error('TypeError')
rangeError = _error('RangeError')
syntaxError = _error('SyntaxError')
error = _error('Error')
printErr = fn! (x) system.stderr.write(x ++ '\n')
panic = fn! (err) {
  err = args[0]
  printErr(err.error)
  # print err.stack if debug level
  exit(err.code)
}

##
## Modules
##
# All imports are qualified, no need to specify a qualifier for local or
# global module, only for third-party. No destructured
# imports, but you can use assignment if you need to.
import system
sys = system
out = sys.stdout
# Print implementation used above.
print = fn! (x) system.stdout.write(x ++ '\n')
import ./foo # Import from local file foo
import ./foo/bar # Import bar from the directory foo
import ../bar # Import from directory above
import bar # Import global
import github.com/zacanger/bar as zbar # Import from installed module
# Assume a file in the same directory called bar.cozy:
a = 1
b = 2
export c = a + 1
f = fn () a
export g = fn () f
# Back in the main file
import ./bar
bar.a # Error
bar.b # error
bar.c # 3
bar.f() # Error
f = bar.g() # function
f() # 1
# Imports and exports must be top level. The following examples would fail.
a = fn foo () {
  import system # Error
  export b = 1 # Error
}

##
## Testing
##
# TODO: tap-compatible library
assertionError = _error('AssertionError')
assertion = fn (expr, message)
  if message != true then assertionError(message, '', 0) else 'Ok'
# TODO:
testSuite = fn! (suiteName, f) {
  print(suiteName)
  f()
}
foo = fn (a, b) a + b
testSuite('test stuff', fn! () {
  assert(1 == 2, 'does one equal two?')
  assert(foo(1, 2) == 3, 'foo works')
})
