# Mathematical constants
let PI = 3.141592653589793;
let E = 2.718281828459045;

# File-objects for STDIN, STDOUT, and STDERR.
# Rather than opening these by name/path we have magic-strings which
# are recognized by our "open" primitive.
let STDIN = fs.open("!STDIN!");
let STDOUT = fs.open("!STDOUT!");
let STDERR = fs.open("!STDERR!");

# The `assert` method allows the code in our standard-library to be
# tested every time it is loaded.
let assert = fn(val, msg = "Result was not 'true'!") {
    let in_repl = sys.getenv("COZY_RUNNING_IN_REPL") == "true"
    if (type(val) == "string") {
        mutable result = eval(val);
        if (!result) {
            print("assert(\"" , val, "\") failed - ", msg);
            if !in_repl {
                sys.exit(1);
            }
        }
    } else {
        if (!val) {
            print(msg);
            if !in_repl {
                sys.exit(1);
            }
        }
    }
};

assert("true");
assert(true);
assert("! false;");
assert(!false);
assert("type(STDIN) == \"file\"");
assert("type(STDOUT) == \"file\"");
assert("type(STDERR) == \"file\"");

let unless = macro(condition, consequence, alternative) {
    quote(if(!(unquote(condition))) {
        unquote(consequence);
    } else {
        unquote(alternative);
    });
};

let array?     = fn (x) { return type(x) == "array" };
let bool?      = fn (x) { return type(x) == "bool" };
let builtin?   = fn (x) { return type(x) == "builtin" };
let docstring? = fn (x) { return type(x) == "docstring" };
let file?      = fn (x) { return type(x) == "file" };
let float?     = fn (x) { return type(x) == "float" };
let function?  = fn (x) { return type(x) == "function" };
let hash?      = fn (x) { return type(x) == "hash" };
let integer?   = fn (x) { return type(x) == "integer" };
let module?    = fn (x) { return type(x) == "module" };
let number?    = fn (x) { return int?(x) || float?(x) };
let regexp?    = fn (x) { return type(x) == "regexp" };
let string?    = fn (x) { return type(x) == "string" };

let memoize = fn (f) {
    mutable results = {}
    return fn () {
        mutable res = []
        foreach x in ... {
            res = res.push(x)
        }
        res = res.join("__cozy__memo__arg__")
        if (results.keys().includes?(res)) {
            return results[res]
        }
        let f_result = f(...)
        results = results.set(res, f_result)
        return f_result
    }
}

# TODO: this is incomplete
let curry = fn (f) {
    mutable f_args = []
    let inner = fn () {
        mutable inner_args = []
        foreach x in ... {
            inner_args = inner_args.push(x)
        }

        if (len(inner_args) > 0) {
            foreach x in inner_args {
                f_args = f_args.push(x)
            }
            return inner
        }

        # TODO: depends on a "spread" type operator
        let res = f(f_args)
        f_args = []
        return res
    }

    return inner
}
