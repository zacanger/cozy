# Mathematical constants
let PI = 3.141592653589793;
let E = 2.718281828459045;

# File-objects for STDIN, STDOUT, and STDERR.
# Rather than opening these by name/path we have magic-strings which
# are recognized by our "open" primitive.
let STDIN = fs.open("!STDIN!");
let STDOUT = fs.open("!STDOUT!");
let STDERR = fs.open("!STDERR!");

# The `assert` method allows the code in our standard-library to be
# tested every time it is loaded.
let assert = fn(val, msg = "Result was not 'true'!") {
    if (type(val) == "string") {
        mutable result = eval(val);
        if (!result) {
            print("assert(\"" , val, "\") failed - ", msg);
            sys.exit(1);
        }
    } else {
        if (!val) {
            print(msg);
            sys.exit(1);
        }
    }
};

assert("true");
assert(true);
assert("! false;");
assert(!false);
assert("type(STDIN) == \"file\"");
assert("type(STDOUT) == \"file\"");
assert("type(STDERR) == \"file\"");

let unless = macro(condition, consequence, alternative) {
    quote(if(!(unquote(condition))) {
        unquote(consequence);
    } else {
        unquote(alternative);
    });
};

let array?     = fn (x) { return type(x) == "array" };
let bool?      = fn (x) { return type(x) == "bool" };
let builtin?   = fn (x) { return type(x) == "builtin" };
let docstring? = fn (x) { return type(x) == "docstring" };
let file?      = fn (x) { return type(x) == "file" };
let float?     = fn (x) { return type(x) == "float" };
let function?  = fn (x) { return type(x) == "function" };
let hash?      = fn (x) { return type(x) == "hash" };
let int?       = fn (x) { return type(x) == "int" };
let module?    = fn (x) { return type(x) == "module" };
let number?    = fn (x) { return int?(x) || float?(x) };
let regexp?    = fn (x) { return type(x) == "regexp" };
let string?    = fn (x) { return type(x) == "string" };
