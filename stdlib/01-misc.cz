# Mathematical constants
let math.constants = {
    "PI": 3.141592653589793,
    "E": 2.718281828459045,
};

# File-objects for STDIN, STDOUT, and STDERR.
# Rather than opening these by name/path we have magic-strings which
# are recognized by our "open" primitive.
let sys.STDIN = fs.open("!STDIN!");
let sys.STDOUT = fs.open("!STDOUT!");
let sys.STDERR = fs.open("!STDERR!");

# TODO: if the ... literal is changed to just return a regular array,
# this function and its usages can go away
let gather_args = fn () {
    # 'gather_args is a global function used to convert an unknown
    # number of arguments into an array. It should be passed the ...
    # literal representing the parent function's args.'
    mutable xs = []
    foreach x in ... {
        xs = xs.push(x)
    }
    return xs
}

let assert = fn(val, msg = "Result was not 'true'!") {
    # 'assert takes a value and an optional failure message.'
    if (!val) {
        print(msg);
        if (!sys.in_repl()) {
            sys.exit(1);
        }
    }
};

assert("true");
assert(true);
assert(!false);
assert(type(sys.STDIN) == "file");
assert(type(sys.STDOUT) == "file");
assert(type(sys.STDERR) == "file");

let unless = macro(condition, consequence, alternative) {
    quote(if(!(unquote(condition))) {
        unquote(consequence);
    } else {
        unquote(alternative);
    });
};

let array? = fn (x) {
    # 'array? returns true if the value provided is an array.'
    return type(x) == "array"
};
let boolean? = fn (x) {
    # 'boolean? returns true if the value provided is a boolean.'
    return type(x) == "bool"
};
let builtin? = fn (x) {
    # 'builtin? returns true if the value provided is a builtin.'
    return type(x) == "builtin"
};
let docstring? = fn (x) {
    # 'docstring? returns true if the value provided is a docstring.'
    return type(x) == "docstring"
};
let file? = fn (x) {
    # 'file? returns true if the value provided is a file.'
    return type(x) == "file"
};
let float? = fn (x) {
    # 'float? returns true if the value provided is a float.'
    return type(x) == "float"
};
let function? = fn (x) {
    # 'function? returns true if the value provided is a function.'
    return type(x) == "function"
};
let hash? = fn (x) {
    # 'hash? returns true if the value provided is a hash.'
    return type(x) == "hash"
};
let integer? = fn (x) {
    # 'integer? returns true if the value provided is an integer.'
    return type(x) == "integer"
};
let module? = fn (x) {
    # 'module? returns true if the value provided is a module.'
    return type(x) == "module"
};
let number? = fn (x) {
    # 'number? returns true if the value provided is an integer or a float.'
    return integer?(x) || float?(x)
};
let string? = fn (x) {
    # 'string? returns true if the value provided is a string.'
    return type(x) == "string"
};

let memoize = fn (f) {
    # 'memoize takes a function and returns a new function,
    # and looks up results based on arguments in its internal cache.'
    mutable results = {}
    return fn () {
        let res = gather_args(...).join("__cozy__memo__arg__")
        if (results.keys().includes?(res)) {
            return results[res]
        }
        let f_result = f(...)
        results = results.set(res, f_result)
        return f_result
    }
}

let curry = fn (f) {
    # 'curry takes a function and curries it so it can be applied gradually.'
    mutable f_args = []
    let inner = fn () {
        let inner_args = gather_args(...)

        if (len(inner_args) > 0) {
            foreach x in inner_args {
                f_args = f_args.push(x)
            }
            return inner
        }

        # TODO: this is incomplete, depends on a "spread" type operator
        let res = f(f_args)
        f_args = []
        return res
    }

    return inner
}

let deep_equals = fn (a, b) {
    # 'deep_equals takes two values and checks for deep equality.'
    if a == b {
        return true
    }

    if type(a) != type(b) {
        return false
    }

    return json.serialize(a) == json.serialize(b)
}
assert(deep_equals(1, 1), "deep_equals works on ints")
assert(deep_equals("a", "a"), "deep_equals works on strings")
assert(deep_equals([1], [1]), "deep_equals works on arrays")
assert(deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){true}}}
), "deep_equals works on complex hashes")
assert(!deep_equals(1, 2), "deep_equals works negative ints")
assert(!deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){false}}}
), "deep_equals works negative complex hashes")
