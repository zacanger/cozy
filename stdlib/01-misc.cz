# Mathematical constants
let math.constants = {
    "PI": 3.141592653589793,
    "E": 2.718281828459045,
};

# File-objects for STDIN, STDOUT, and STDERR.
# Rather than opening these by name/path we have magic-strings which
# are recognized by our "open" primitive.
let sys.STDIN = fs.open("!STDIN!");
let sys.STDOUT = fs.open("!STDOUT!");
let sys.STDERR = fs.open("!STDERR!");

let sys.in_repl = fn () {
    'sys.in_repl returns true if the current cozy process is in a repl'
    return sys.getenv("COZY_RUNNING_IN_REPL") == "true"
};

let util.array_from = fn () {
    'array_from is a global function used to convert an unknown
    number of arguments into an array. It should be passed the ...
    literal representing the parent function\'s args.'
    mutable xs = []
    foreach x in ... {
        xs = xs.append(x)
    }
    return xs
}

let util.assert = fn(val, msg = "Result was not 'true'!") {
    'assert takes a value and an optional failure message.'
    if (!val) {
        print(msg);
        if (!sys.in_repl()) {
            sys.exit(1);
        }
    }
};

util.assert("true");
util.assert(true);
util.assert(!false);
util.assert(util.type(sys.STDIN) == "file");
util.assert(util.type(sys.STDOUT) == "file");
util.assert(util.type(sys.STDERR) == "file");

let util.array? = fn (x) {
    'array? returns true if the value provided is an array.'
    return util.type(x) == "array"
};
let util.boolean? = fn (x) {
    'boolean? returns true if the value provided is a boolean.'
    return util.type(x) == "bool"
};
let util.builtin? = fn (x) {
    'builtin? returns true if the value provided is a builtin.'
    return util.type(x) == "builtin"
};
let util.docstring? = fn (x) {
    'docstring? returns true if the value provided is a docstring.'
    return util.type(x) == "docstring"
};
let util.file? = fn (x) {
    'file? returns true if the value provided is a file.'
    return util.type(x) == "file"
};
let util.float? = fn (x) {
    'float? returns true if the value provided is a float.'
    return util.type(x) == "float"
};
let util.function? = fn (x) {
    'function? returns true if the value provided is a function.'
    return util.type(x) == "function"
};
let util.hash? = fn (x) {
    'hash? returns true if the value provided is a hash.'
    return util.type(x) == "hash"
};
let util.integer? = fn (x) {
    'integer? returns true if the value provided is an integer.'
    return util.type(x) == "integer"
};
let util.module? = fn (x) {
    'module? returns true if the value provided is a module.'
    return util.type(x) == "module"
};
let util.number? = fn (x) {
     'number? returns true if the value provided is an integer or a float.'
    return util.integer?(x) || util.float?(x)
};
let util.string? = fn (x) {
    'string? returns true if the value provided is a string.'
    return util.type(x) == "string"
};
let util.error? = fn (x) {
    'error? returns true if the value provided is an error.'
    return util.type(x) == "error"
};

let util.memoize = fn (f) {
    'memoize takes a function and returns a new function,
    and looks up results based on arguments in its internal cache.'
    mutable results = {}
    return fn () {
        let res = util.array_from(...).join("__cozy__memo__arg__")
        if (results.keys().includes?(res)) {
            return results[res]
        }
        let f_result = f(...)
        results = results.set(res, f_result)
        return f_result
    }
}

let util.curry = fn (f) {
    'curry takes a function and curries it so it can be applied gradually.'
    mutable f_args = []
    let inner = fn () {
        let inner_args = util.array_from(...)

        if (util.len(inner_args) > 0) {
            foreach x in inner_args {
                f_args = f_args.append(x)
            }
            return inner
        }

        # TODO: why is spread not working here?
        # foreach ff in ....f_args { print(ff) }
        let res = f(....f_args)
        f_args = []
        return res
    }

    return inner
}

let util.deep_equals = fn (a, b) {
    'deep_equals takes two values and checks for deep equality.'
    if a == b {
        return true
    }

    if util.type(a) != util.type(b) {
        return false
    }

    return json.serialize(a) == json.serialize(b)
}
util.assert(util.deep_equals(1, 1), "deep_equals works on ints")
util.assert(util.deep_equals("a", "a"), "deep_equals works on strings")
util.assert(util.deep_equals([1], [1]), "deep_equals works on arrays")
util.assert(util.deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){true}}}
), "deep_equals works on complex hashes")
util.assert(!util.deep_equals(1, 2), "deep_equals works negative ints")
util.assert(!util.deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){false}}}
), "deep_equals works negative complex hashes")

let util.colorize = (fn () {
    let color_codes = {
        "reset": 0,
        "bold": 1,
        "dim": 2,
        "italic": 3,
        "underline": 4,
        "blink": 5,
        "inverse": 7,
        "hidden": 8,
        "strikethrough": 9,
        "doubleunderline": 21,
        "black": 30,
        "red": 31,
        "green": 32,
        "yellow": 33,
        "blue": 34,
        "magenta": 35,
        "cyan": 36,
        "white": 37,
        "bg_black": 40,
        "bg_red": 41,
        "bg_green": 42,
        "bg_yellow": 43,
        "bg_blue": 44,
        "bg_magenta": 45,
        "bg_cyan": 46,
        "bg_white": 47,
        "framed": 51,
        "overlined": 53,
        "gray": 90,
        "red_bright": 91,
        "green_bright": 92,
        "yellow_bright": 93,
        "blue_bright": 94,
        "magenta_bright": 95,
        "cyan_bright": 96,
        "white_bright": 97,
        "bg_gray": 100,
        "bg_red_bright": 101,
        "bg_green_bright": 102,
        "bg_yellow_bright": 103,
        "bg_blue_bright": 104,
        "bg_magenta_bright": 105,
        "bg_cyan_bright": 106,
        "bg_white_bright": 107
    };

    let apply_col = fn (col) {
        return fn (content) {
            let code = color_codes[col]
            let s = "\\033[1;"
            let col_s = s + util.string(code) + "m"
            let reset_s = s + util.string(color_codes["reset"]) + "m"
            return col_s + content + reset_s
        }
    }

    mutable ret = {}

    # TODO: some kind of race condition where not all
    # colors are getting added in? any given color seems to
    # fail about half the time
    foreach k in color_codes {
        ret = ret.set(k, apply_col(k))
    }

    return ret
})();
