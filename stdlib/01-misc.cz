# Mathematical constants
let math.constants = {
    "PI": 3.141592653589793,
    "E": 2.718281828459045,
};

# File-objects for STDIN, STDOUT, and STDERR.
# Rather than opening these by name/path we have magic-strings which
# are recognized by our "open" primitive.
let sys.STDIN = fs.open("!STDIN!");
let sys.STDOUT = fs.open("!STDOUT!");
let sys.STDERR = fs.open("!STDERR!");

let sys.in_repl = fn () {
    'sys.in_repl returns true if the current cozy process is in a repl'
    return sys.getenv("COZY_RUNNING_IN_REPL") == "true"
};

let array_from = fn () {
    'array_from is a global function used to convert an unknown
    number of arguments into an array. It should be passed the ...
    literal representing the parent function\'s args.'
    mutable xs = []
    foreach x in ... {
        xs = xs.append(x)
    }
    return xs
}

let assert = fn(val, msg = "Result was not 'true'!") {
    'assert takes a value and an optional failure message.'
    if (!val) {
        print(msg);
        if (!sys.in_repl()) {
            sys.exit(1);
        }
    }
};

assert("true");
assert(true);
assert(!false);
assert(type(sys.STDIN) == "file");
assert(type(sys.STDOUT) == "file");
assert(type(sys.STDERR) == "file");

let array? = fn (x) {
    'array? returns true if the value provided is an array.'
    return type(x) == "array"
};
let boolean? = fn (x) {
    'boolean? returns true if the value provided is a boolean.'
    return type(x) == "bool"
};
let builtin? = fn (x) {
    'builtin? returns true if the value provided is a builtin.'
    return type(x) == "builtin"
};
let docstring? = fn (x) {
    'docstring? returns true if the value provided is a docstring.'
    return type(x) == "docstring"
};
let file? = fn (x) {
    'file? returns true if the value provided is a file.'
    return type(x) == "file"
};
let float? = fn (x) {
    'float? returns true if the value provided is a float.'
    return type(x) == "float"
};
let function? = fn (x) {
    'function? returns true if the value provided is a function.'
    return type(x) == "function"
};
let hash? = fn (x) {
    'hash? returns true if the value provided is a hash.'
    return type(x) == "hash"
};
let integer? = fn (x) {
    'integer? returns true if the value provided is an integer.'
    return type(x) == "integer"
};
let module? = fn (x) {
    'module? returns true if the value provided is a module.'
    return type(x) == "module"
};
let number? = fn (x) {
     'number? returns true if the value provided is an integer or a float.'
    return integer?(x) || float?(x)
};
let string? = fn (x) {
    'string? returns true if the value provided is a string.'
    return type(x) == "string"
};
let error? = fn (x) {
    'error? returns true if the value provided is an error.'
    return type(x) == "error"
};

let memoize = fn (f) {
    'memoize takes a function and returns a new function,
    and looks up results based on arguments in its internal cache.'
    mutable results = {}
    return fn () {
        let res = array_from(...).join("__cozy__memo__arg__")
        if (results.keys().includes?(res)) {
            return results[res]
        }
        let f_result = f(...)
        results = results.set(res, f_result)
        return f_result
    }
}

let curry = fn (f) {
    'curry takes a function and curries it so it can be applied gradually.'
    mutable f_args = []
    let inner = fn () {
        let inner_args = array_from(...)

        if (len(inner_args) > 0) {
            foreach x in inner_args {
                f_args = f_args.append(x)
            }
            return inner
        }

        # TODO: why is spread not working here?
        let res = f(....f_args)
        f_args = []
        return res
    }

    return inner
}

let deep_equals = fn (a, b) {
    'deep_equals takes two values and checks for deep equality.'
    if a == b {
        return true
    }

    if type(a) != type(b) {
        return false
    }

    return json.serialize(a) == json.serialize(b)
}
assert(deep_equals(1, 1), "deep_equals works on ints")
assert(deep_equals("a", "a"), "deep_equals works on strings")
assert(deep_equals([1], [1]), "deep_equals works on arrays")
assert(deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){true}}}
), "deep_equals works on complex hashes")
assert(!deep_equals(1, 2), "deep_equals works negative ints")
assert(!deep_equals(
    {"x":[1],"y":{"z":fn(){true}}},
    {"x":[1],"y":{"z":fn(){false}}}
), "deep_equals works negative complex hashes")
